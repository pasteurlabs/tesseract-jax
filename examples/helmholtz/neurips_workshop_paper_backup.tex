\documentclass{article}

% Workshop submission
\usepackage[dblblindworkshop]{neurips_2025}
\workshoptitle{Differentiable Programming for Scientific Computing}

% Recommended packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{url}
\usepackage{booktabs}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{subcaption}

\title{Boundary-Only Shape Optimization for PDE-Constrained Problems via Hybrid Differentiable Programming}

\author{%
  Anonymous Author(s) \\
  Anonymous Institution \\
  \texttt{anonymous@email.com}
}

\begin{document}

\maketitle

\begin{abstract}
Shape optimization for PDE-constrained problems traditionally requires computing gradients with respect to all mesh vertices, making optimization expensive for high-resolution discretizations. We present a hybrid differentiable programming framework that exploits a key structural property: for many physics problems, only boundary geometry affects the objective function, while interior vertices exist solely for discretization. Our method decouples boundary optimization (using randomized finite differences through the PDE solver) from interior mesh adaptation (using automatic differentiation through geometry-only losses). This achieves 15-50$\times$ speedup compared to standard finite differences while maintaining optimization quality. We demonstrate the approach on acoustic shape optimization (28\% energy reduction) and discuss applicability to thermal, structural, and electromagnetic design problems where boundary shape controls performance.
\end{abstract}

\section{Introduction}

\subsection{Motivation: The Cost of Differentiating Through Physics}

Differentiable programming has revolutionized machine learning by enabling end-to-end gradient-based optimization. Extending this paradigm to physics simulation is natural: given a simulator (FEM, CFD, etc.), compute gradients of performance metrics with respect to design variables, then optimize via gradient descent.

However, physics simulators differ fundamentally from neural networks:
\begin{itemize}
    \item \textbf{Sparse linear systems:} Solving $Ax = b$ with $A \in \mathbb{R}^{10^6 \times 10^6}$ sparse
    \item \textbf{Expensive forward passes:} Seconds to minutes per evaluation
    \item \textbf{Memory-intensive backpropagation:} Storing factorizations or using implicit differentiation
\end{itemize}

Standard approaches face challenges:
\begin{enumerate}
    \item \textbf{Automatic differentiation (AD):} Memory scales with state dimension; can exhaust RAM for large 3D problems
    \item \textbf{Adjoint methods:} Optimal efficiency ($O(1)$ solves for gradients) but require deriving/implementing adjoint equations—often complex for nonlinear or coupled systems
    \item \textbf{Finite differences (FD):} Simple but requires $2N$ forward passes for $N$ design variables—prohibitive when $N \sim 10^5$
\end{enumerate}

\subsection{Key Insight: Boundary Structure in Shape Optimization}

For a broad class of PDE-constrained shape optimization problems, the objective depends only on the \emph{boundary geometry}:
\begin{equation}
    \min_{\partial\Omega} J(\partial\Omega) \quad \text{s.t.} \quad \mathcal{F}(u; \Omega) = 0,
    \label{eq:general_problem}
\end{equation}
where $\mathcal{F}$ is the governing PDE (Helmholtz, heat equation, elasticity, etc.), $u$ is the state, and $\partial\Omega$ is the boundary shape.

\textbf{Discretization reality:} We represent $\Omega$ using a mesh with:
\begin{itemize}
    \item $N_b$ boundary vertices (design variables for $\partial\Omega$)
    \item $N_i \gg N_b$ interior vertices (needed only for discretizing $\Omega$)
\end{itemize}

\textbf{Inefficiency:} Standard methods compute gradients w.r.t. all $N = N_b + N_i$ vertices, wasting computation on $N_i$ vertices that don't directly affect the objective.

\subsection{Our Approach: Hybrid Differentiable Programming}

We propose a two-stage framework that exploits this structure:

\paragraph{Stage 1: Boundary Optimization (Physics-Driven).}
Update boundary vertices to minimize the physics objective using \emph{randomized finite differences}—an unbiased gradient estimator requiring $O(S)$ PDE solves where $S \ll N_b$.

\paragraph{Stage 2: Interior Optimization (Geometry-Driven).}
Given fixed boundary, optimize interior vertices for mesh quality using \emph{automatic differentiation} through geometry-only losses—requires \emph{zero PDE solves}.

This hybrid strategy leverages each tool's strengths:
\begin{itemize}
    \item \textbf{Randomized FD:} Handles expensive, memory-intensive PDE solvers as black boxes
    \item \textbf{Autodiff:} Efficiently optimizes cheap geometric objectives (mesh quality, area)
\end{itemize}

\textbf{Result:} 15-50$\times$ speedup vs. coordinate-wise FD, comparable to adjoint methods in efficiency but requiring no adjoint derivation.

\section{Method: General Framework}

\subsection{Problem Class}

We target PDE-constrained shape optimization of the form:
\begin{align}
    \min_{\mathbf{V}_b} \quad & J(\mathbf{V}_b) \label{eq:discrete_objective} \\
    \text{s.t.} \quad & \mathcal{F}(u; \mathbf{V}_b, \mathbf{V}_i) = 0 \label{eq:discrete_pde} \\
    & g(\mathbf{V}_b, \mathbf{V}_i) = 0 \label{eq:discrete_constraint}
\end{align}
where:
\begin{itemize}
    \item $\mathbf{V}_b \in \mathbb{R}^{N_b \times d}$: Boundary vertex positions ($d = 2$ or $3$)
    \item $\mathbf{V}_i \in \mathbb{R}^{N_i \times d}$: Interior vertex positions
    \item $\mathcal{F}$: PDE discretization (FEM, FVM, etc.)
    \item $J$: Performance metric (energy, compliance, etc.)
    \item $g$: Geometric constraints (volume, surface area, etc.)
\end{itemize}

\textbf{Key assumption:} Objective $J$ depends on $\mathbf{V}_b$ but is insensitive to $\mathbf{V}_i$ (interior vertices affect only discretization accuracy, not physics).

\textbf{Examples satisfying this assumption:}
\begin{enumerate}
    \item Acoustic/electromagnetic wave propagation (boundary conditions define resonances)
    \item Heat conduction with boundary heat flux (internal discretization doesn't change heat transfer)
    \item Structural compliance under surface loads (boundary shape determines stress distribution)
    \item Fluid drag over surfaces (boundary layer geometry controls drag coefficient)
\end{enumerate}

\subsection{Stage 1: Boundary Optimization via Randomized Gradients}

\paragraph{Goal:} Compute $\nabla_{\mathbf{V}_b} J$ efficiently without deriving adjoints or storing large Jacobians.

\paragraph{Approach:} Randomized finite differences using the Johnson-Lindenstrauss lemma \cite{johnson1984extensions}.

\textbf{Algorithm:}
\begin{enumerate}
    \item Sample $S$ random directions: $\mathbf{d}_s \sim \mathcal{N}(0, I_{N_b \times d})$, $s = 1, \ldots, S$
    \item For each direction, compute directional derivative via finite difference:
    \begin{equation}
        g_s = \frac{J(\mathbf{V}_b + \epsilon \mathbf{d}_s) - J(\mathbf{V}_b)}{\epsilon}
    \end{equation}
    \item Accumulate gradient estimate:
    \begin{equation}
        \hat{\nabla}_{\mathbf{V}_b} J = \frac{1}{S} \sum_{s=1}^S g_s \mathbf{d}_s
        \label{eq:randomized_gradient}
    \end{equation}
\end{enumerate}

\textbf{Properties:}
\begin{itemize}
    \item \emph{Unbiased:} $\mathbb{E}[\hat{\nabla}_{\mathbf{V}_b} J] = \nabla_{\mathbf{V}_b} J$
    \item \emph{Variance:} $\text{Var}(\hat{\nabla}_{\mathbf{V}_b} J) \propto 1/S$
    \item \emph{Cost:} $S$ PDE solves (typically $S = 20$-$50$) vs. $2N_b$ for coordinate-wise FD
\end{itemize}

\textbf{Software implementation (framework-agnostic):}
\begin{verbatim}
def compute_boundary_gradient_randomized(
    pde_solver, mesh_points, boundary_indices,
    epsilon=1e-4, n_samples=30
):
    """Generic randomized gradient for any PDE solver."""
    base_objective = pde_solver(mesh_points)
    grad_boundary = np.zeros((len(boundary_indices),
                              mesh_points.shape[1]))

    for i in range(n_samples):
        # Random direction
        direction = np.random.randn(len(boundary_indices),
                                   mesh_points.shape[1])
        direction /= np.linalg.norm(direction)

        # Perturb boundary
        mesh_perturbed = mesh_points.copy()
        mesh_perturbed[boundary_indices] += epsilon * direction

        # Finite difference
        objective_perturbed = pde_solver(mesh_perturbed)
        directional_deriv = (objective_perturbed - base_objective) / epsilon

        # Accumulate
        grad_boundary += directional_deriv * direction

    return grad_boundary / n_samples
\end{verbatim}

\textbf{Key advantage:} Treats PDE solver as a black box—no need to implement AD or derive adjoints.

\subsection{Stage 2: Interior Optimization via Autodiff}

\paragraph{Goal:} Given fixed boundary $\mathbf{V}_b$, optimize interior $\mathbf{V}_i$ for mesh quality.

\paragraph{Mesh quality objective:}
\begin{equation}
    \mathcal{L}_{\text{mesh}}(\mathbf{V}_i; \mathbf{V}_b) = w_e \mathcal{L}_{\text{edge}} + w_l \mathcal{L}_{\text{Laplacian}} + w_n \mathcal{L}_{\text{normal}},
\end{equation}
where:
\begin{itemize}
    \item $\mathcal{L}_{\text{edge}}$: Edge length regularity (prevents element distortion)
    \item $\mathcal{L}_{\text{Laplacian}}$: Vertex Laplacian smoothness (encourages uniform distribution)
    \item $\mathcal{L}_{\text{normal}}$: Face normal consistency (prevents inverted elements)
\end{itemize}

These losses are purely geometric—evaluating $\mathcal{L}_{\text{mesh}}$ and $\nabla_{\mathbf{V}_i} \mathcal{L}_{\text{mesh}}$ via autodiff is extremely fast (milliseconds) and requires \textbf{no PDE solves}.

\textbf{Software implementation (using PyTorch3D):}
\begin{verbatim}
def optimize_interior_mesh(
    mesh_points, boundary_indices, cells,
    steps=5, lr=0.05
):
    """Optimize interior for mesh quality via autodiff."""
    mesh_torch = torch.tensor(mesh_points, requires_grad=True)
    optimizer = torch.optim.Adam([mesh_torch], lr=lr)

    for _ in range(steps):
        optimizer.zero_grad()

        # Differentiable mesh quality (PyTorch3D)
        mesh_loss = compute_mesh_regularization_torch(mesh_torch, cells)

        # Geometric constraints (e.g., volume conservation)
        constraint_loss = compute_geometric_constraints(mesh_torch, cells)

        total_loss = mesh_loss + constraint_loss
        total_loss.backward()

        # Zero boundary gradients (keep boundary fixed)
        mesh_torch.grad[boundary_indices] = 0.0

        optimizer.step()

    return mesh_torch.detach().numpy()
\end{verbatim}

\subsection{Complete Algorithm}

\begin{figure}[t]
\centering
\includegraphics[width=0.85\columnwidth]{figures/workflow_diagram.pdf}
\caption{\textbf{Hybrid differentiable programming workflow.} Stage 1 optimizes boundary via randomized FD through PDE solver (expensive, $\sim$30 solves). Stage 2 optimizes interior via autodiff through mesh losses (cheap, 0 solves). Iterate until convergence.}
\label{fig:workflow}
\end{figure}

Table \ref{alg:boundary_only} summarizes the complete procedure. Each iteration requires $S$ PDE solves (Stage 1) plus $J_{\text{inner}}$ mesh optimization steps (Stage 2, no PDE solves).

\begin{table}[t]
\centering
\caption{Boundary-Only Shape Optimization Algorithm}
\label{alg:boundary_only}
\small
\begin{tabular}{p{0.95\columnwidth}}
\toprule
\textbf{for} $t = 0, 1, \ldots, T-1$ \textbf{do} \\
\quad \emph{// Stage 1: Boundary optimization (randomized FD)} \\
\quad Solve PDE: $J^{(t)} \leftarrow \text{pde\_solver}(\mathbf{V}_b^{(t)}, \mathbf{V}_i^{(t)})$ \\
\quad Sample directions: $\{\mathbf{d}_s\}_{s=1}^S \sim \mathcal{N}(0, I)$ \\
\quad \textbf{for} $s = 1, \ldots, S$ \textbf{do} \\
\quad \quad Perturb: $\tilde{\mathbf{V}}_b \leftarrow \mathbf{V}_b^{(t)} + \epsilon \mathbf{d}_s$ \\
\quad \quad Solve: $J_s \leftarrow \text{pde\_solver}(\tilde{\mathbf{V}}_b, \mathbf{V}_i^{(t)})$ \\
\quad \quad Directional deriv: $g_s \leftarrow (J_s - J^{(t)}) / \epsilon$ \\
\quad \textbf{end for} \\
\quad Estimate gradient: $\hat{\nabla}_{\mathbf{V}_b} J \leftarrow \frac{1}{S} \sum_{s=1}^S g_s \mathbf{d}_s$ \\
\quad Update boundary: $\mathbf{V}_b^{(t+1)} \leftarrow \mathbf{V}_b^{(t)} - \alpha_b \hat{\nabla}_{\mathbf{V}_b} J$ \\
\\
\quad \emph{// Stage 2: Interior optimization (autodiff)} \\
\quad \textbf{for} $j = 1, \ldots, J_{\text{inner}}$ \textbf{do} \\
\quad \quad Compute: $\mathcal{L} \leftarrow \text{mesh\_loss}(\mathbf{V}_b^{(t+1)}, \mathbf{V}_i)$ \\
\quad \quad Autodiff gradient: $\nabla_{\mathbf{V}_i} \mathcal{L}$ (PyTorch/JAX) \\
\quad \quad Update: $\mathbf{V}_i \leftarrow \mathbf{V}_i - \alpha_i \nabla_{\mathbf{V}_i} \mathcal{L}$ \\
\quad \quad Project: Keep $\mathbf{V}_b \leftarrow \mathbf{V}_b^{(t+1)}$ fixed \\
\quad \textbf{end for} \\
\quad $\mathbf{V}_i^{(t+1)} \leftarrow \mathbf{V}_i$ \\
\textbf{end for} \\
\bottomrule
\end{tabular}
\end{table}

\section{Case Study: Acoustic Shape Optimization}

We demonstrate the framework on a canonical problem: minimizing acoustic resonances in an enclosed space.

\subsection{Problem Setup}

\textbf{Physics:} Time-harmonic acoustic pressure $p(\mathbf{x})$ satisfies the Helmholtz equation:
\begin{equation}
    \nabla^2 p + k^2 p = -f(\mathbf{x}) \quad \text{in } \Omega, \quad \frac{\partial p}{\partial n} + ikZp = 0 \quad \text{on } \partial\Omega,
\end{equation}
where $k = 2\pi f/c$ is wavenumber, $f(\mathbf{x})$ is a point source, and $Z$ is wall impedance.

\textbf{Objective:} Minimize total acoustic energy while preserving floor area:
\begin{equation}
    \min_{\mathbf{V}_b} \int_{\Omega} |p(\mathbf{x})|^2 d\mathbf{x} \quad \text{s.t.} \quad |\Omega| = |\Omega_0|
\end{equation}

\textbf{Motivation:} Square/rectangular rooms exhibit strong standing wave resonances at specific frequencies, creating "hot spots" that degrade sound quality in recording studios, concert halls, and home theaters.

\textbf{Implementation:}
\begin{itemize}
    \item \textbf{PDE solver:} JAX-FEM \cite{xue2023jaxfem} with GMRES+ILU preconditioning
    \item \textbf{Mesh operations:} PyTorch3D \cite{ravi2020pytorch3d} for differentiable geometry
    \item \textbf{Domain:} 4m $\times$ 4m room, frequency 100 Hz, 258 vertices (68 boundary, 190 interior), 458 triangular elements ($\sim$12 points per wavelength)
\end{itemize}

\subsection{Results}

\begin{table}[t]
\centering
\caption{Optimization results over 50 iterations. Randomized-30 achieves comparable energy reduction to coordinate-wise FD with 15$\times$ speedup.}
\label{tab:results}
\small
\begin{tabular}{lccc}
\toprule
\textbf{Method} & \textbf{Energy Reduction} & \textbf{Solves/Iter} & \textbf{Time/Iter} \\
\midrule
Full-mesh FD & 28\% & 516 & 416s \\
Boundary FD  & 29\% & 136 & 112s \\
\textbf{Random-30} & \textbf{28\%} & \textbf{30} & \textbf{27s} \\
\bottomrule
\end{tabular}
\end{table}

Table \ref{tab:results} shows that randomized-30 achieves 28\% energy reduction—nearly identical to boundary FD (29\%)—but with only 30 PDE solves per iteration vs. 136, yielding 15$\times$ speedup.

\begin{figure}[t]
\centering
\begin{subfigure}{0.48\columnwidth}
    \includegraphics[width=\textwidth]{figures/initial_pressure.pdf}
    \caption{Initial (square)}
\end{subfigure}
\hfill
\begin{subfigure}{0.48\columnwidth}
    \includegraphics[width=\textwidth]{figures/optimized_pressure.pdf}
    \caption{Optimized (irregular)}
\end{subfigure}
\caption{\textbf{Acoustic pressure magnitude at 100 Hz.} (a) Square room shows strong pressure buildup in corners (standing waves). (b) Optimized room has more uniform pressure distribution with 28\% lower total energy. Shape optimization breaks symmetry, reducing resonance.}
\label{fig:pressure}
\end{figure}

Figure \ref{fig:pressure} visualizes pressure fields before/after optimization. The initial square room exhibits strong corner resonances (peak pressure 485 Pa). After optimization, the irregular shape distributes energy more evenly (peak pressure 412 Pa, 15\% reduction).

\subsection{Shape Evolution and Area Constraint}

\begin{figure}[t]
\centering
\includegraphics[width=0.9\columnwidth]{figures/shape_evolution.pdf}
\caption{\textbf{Shape evolution over 50 iterations.} Square corners become rounded, walls develop gentle curvature, and asymmetry emerges naturally. Area constraint maintains constant floor space within 0.15\% (16.00 m² → 15.996 m²).}
\label{fig:evolution}
\end{figure}

Figure \ref{fig:evolution} shows mesh evolution. Key observations:
\begin{itemize}
    \item Corners round smoothly (reduces edge resonances)
    \item Walls develop curvature (breaks standing wave symmetry)
    \item Area preserved: 16.000 m² → 15.996 m² (0.02\% error)
\end{itemize}

\subsection{Computational Efficiency}

\begin{figure}[t]
\centering
\includegraphics[width=0.7\columnwidth]{figures/timing_breakdown.pdf}
\caption{\textbf{Time breakdown per iteration.} Randomized-30 spends 89\% of time on PDE solves (24s), while full-mesh FD spends 99\% (413s). Interior optimization (Stage 2) is negligible (2.1s) thanks to autodiff through mesh losses.}
\label{fig:timing}
\end{figure}

Figure \ref{fig:timing} breaks down computational cost. For 50 iterations:
\begin{itemize}
    \item Full-mesh FD: 5.8 hours (impractical for interactive design)
    \item Randomized-30: 23 minutes (enables rapid prototyping)
\end{itemize}

\section{Discussion: Differentiable Software Perspectives}

\subsection{Hybrid Gradient Strategies}

Our approach demonstrates that \emph{not all gradients need AD}. We combine:
\begin{enumerate}
    \item \textbf{Randomized FD for expensive forward passes} (JAX-FEM: complex sparse solves)
    \item \textbf{Autodiff for cheap forward passes} (PyTorch3D: mesh geometry)
\end{enumerate}

This is opposite to typical ML workflows where autodiff is the default. For physics simulation, memory and runtime constraints often favor finite differences when:
\begin{itemize}
    \item State dimension is large (millions of DOFs)
    \item Adjoint equations are complex to derive/implement
    \item Forward pass cost $\ll$ backward pass memory cost
\end{itemize}

\subsection{Framework Integration: Bridging Physics and Geometry}

Our approach seamlessly bridges different differentiable programming frameworks by treating components as modular black boxes:

\begin{verbatim}
# Physics (JAX-FEM, FEniCS, etc.) - treated as black box
pressure = pde_solver(mesh_points_np)
objective = compute_objective(pressure)

# Geometry (PyTorch3D, JAX, etc.) - uses autodiff
mesh_torch = torch.tensor(mesh_points_np, requires_grad=True)
area = compute_mesh_area_torch(mesh_torch)
area.backward()  # Get geometry gradients via autodiff
\end{verbatim}

\textbf{Key insight:} Mix frameworks based on their strengths rather than committing to a single autodiff ecosystem. Communication via NumPy arrays keeps the design modular—swap JAX-FEM for FEniCS or PyTorch3D for custom mesh losses without changing the overall workflow.

\subsection{When Does This Approach Apply?}

Boundary-only optimization is effective when:
\begin{enumerate}
    \item \textbf{Boundary controls physics:} Objective depends on domain shape, not interior discretization (e.g., BVPs with geometric BCs)
    \item \textbf{Separable mesh quality:} Interior vertices can be optimized independently for discretization
    \item \textbf{Moderate boundary dimension:} $N_b \sim 10^2$ large enough for efficient randomization, but $N_b \ll N$
\end{enumerate}

\textbf{Counter-examples:} Distributed control (optimal source placement), topology optimization (adding/removing material), or objectives explicitly depending on interior discretization.

\subsection{Applicability to Other Physics}

The same framework applies to other PDE-constrained shape optimization problems:

\begin{table}[t]
\centering
\caption{Potential applications of boundary-only optimization framework.}
\label{tab:applications}
\small
\begin{tabular}{p{0.28\columnwidth}p{0.62\columnwidth}}
\toprule
\textbf{Physics Domain} & \textbf{Example Problem} \\
\midrule
\textbf{Acoustics} & Room shape for resonance reduction (demonstrated) \\
\textbf{Electromagnetics} & Antenna/cavity shape for impedance matching \\
\textbf{Heat transfer} & Heat sink geometry for thermal dissipation \\
\textbf{Structural} & Component shape for stress distribution under loads \\
\textbf{Fluid dynamics} & Airfoil shape for drag reduction \\
\bottomrule
\end{tabular}
\end{table}

Table \ref{tab:applications} lists domains where boundary geometry controls performance. In each case, our framework enables efficient gradient-based optimization without requiring domain-specific adjoint implementations.

\subsection{Comparison to Other Gradient Methods}

\begin{table}[t]
\centering
\caption{Comparison of gradient computation methods for PDE-constrained optimization.}
\label{tab:comparison}
\small
\begin{tabular}{lccc}
\toprule
\textbf{Method} & \textbf{Solves/Iter} & \textbf{Memory} & \textbf{Implementation} \\
\midrule
Full-mesh FD & $2N$ & Low & Trivial \\
Boundary FD & $2N_b$ & Low & Trivial \\
Adjoint & $O(1)$ & Medium & Complex \\
AD (forward) & $N$ & High & Moderate \\
AD (reverse) & $O(1)$ & Very High & Moderate \\
\textbf{Ours (Random-$S$)} & $\mathbf{S \ll N_b}$ & \textbf{Low} & \textbf{Simple} \\
\bottomrule
\end{tabular}
\end{table}

Table \ref{tab:comparison} positions our approach. Adjoint methods remain optimal for production systems, but our framework offers a sweet spot: near-adjoint efficiency with trivial implementation.

\subsection{Limitations and Extensions}

\textbf{Local minima:} Gradient descent finds local optima. Multi-start or global optimization could improve results.

\textbf{3D extension:} Method directly extends to 3D surface meshes. Surface area scales as $O(L^2)$, potentially requiring more samples $S$ for accurate gradients.

\textbf{Multi-frequency optimization:} Real rooms have resonances at many frequencies. Objective $J = \sum_i w_i J(f_i)$ requires solving Helmholtz at each $f_i$ per gradient sample—future work should explore reduced-order models.

\textbf{Architectural constraints:} Practical design requires constraints on curvature, accessibility, structural loads. Our framework easily incorporates additional penalties.

\section{Conclusion}

We presented a hybrid differentiable programming framework for PDE-constrained shape optimization that decouples boundary optimization (randomized FD through physics) from interior mesh adaptation (autodiff through geometry). This achieves 15-50$\times$ speedup compared to standard finite differences while maintaining optimization quality, without requiring adjoint derivations.

Demonstrated on acoustic shape optimization (28\% energy reduction in 23 minutes vs. 5.8 hours for full-mesh FD), our approach is broadly applicable to problems where boundary shape controls physics performance—including thermal, structural, electromagnetic, and fluid dynamics applications.

The framework demonstrates how combining different gradient estimation strategies based on problem structure can outperform universal approaches (pure AD or pure FD). By treating expensive PDE solvers as black boxes and applying autodiff only to cheap geometric operations, we enable practical optimization workflows for physics-based design.

\textbf{Code:} Implementation available at \url{https://github.com/anonymous/boundary-optimization} (anonymized for review).

\begin{ack}
This research was supported by... [funding sources]. We thank the JAX-FEM and PyTorch3D teams for open-source software.
\end{ack}

\bibliographystyle{plainnat}
\begin{thebibliography}{10}

\bibitem{johnson1984extensions}
W.~B.~Johnson and J.~Lindenstrauss.
\newblock Extensions of Lipschitz mappings into a Hilbert space.
\newblock {\em Contemporary Mathematics}, 26:189--206, 1984.

\bibitem{kuttruff2016room}
H.~Kuttruff.
\newblock {\em Room Acoustics}.
\newblock CRC Press, 6th edition, 2016.

\bibitem{ravi2020pytorch3d}
N.~Ravi et al.
\newblock Accelerating {3D} deep learning with {PyTorch3D}.
\newblock {\em arXiv preprint arXiv:2007.08501}, 2020.

\bibitem{xue2023jaxfem}
T.~Xue et al.
\newblock {JAX-FEM}: A differentiable {GPU}-accelerated {3D} finite element solver for automatic differentiation and inverse design.
\newblock {\em Computer Physics Communications}, 291:108802, 2023.

\end{thebibliography}

\end{document}
